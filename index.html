<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Torneo dei Piatti Italiani</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Lora:ital,wght@0,400..700;1,400..700&display=swap" rel="stylesheet">
    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, collection, query, onSnapshot, updateDoc, arrayUnion, arrayRemove, deleteDoc, getDoc, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global variables for Firebase (will be populated by Canvas environment)
        window.__app_id = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        window.__firebase_config = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        window.__initial_auth_token = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        window.firebaseApp = initializeApp(window.__firebase_config);
        window.db = getFirestore(window.firebaseApp);
        window.auth = getAuth(window.firebaseApp);

        // Exporting for use in main script block
        window.firebase = {
            auth: window.auth,
            db: window.db,
            signInAnonymously: signInAnonymously,
            signInWithCustomToken: signInWithCustomToken,
            onAuthStateChanged: onAuthStateChanged,
            setDoc: setDoc,
            collection: collection,
            query: query,
            onSnapshot: onSnapshot,
            updateDoc: updateDoc,
            arrayUnion: arrayUnion,
            arrayRemove: arrayRemove,
            deleteDoc: deleteDoc,
            doc: doc,
            getDoc: getDoc,
            serverTimestamp: serverTimestamp
        };
    </script>

    <style>
        body {
            font-family: 'Montserrat', sans-serif;
            background-color: #fdf7f1;
            color: #4a4a4a;
        }
        .title-font {
            font-family: 'Lora', serif;
        }
        .bracket-container {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding: 1rem; /* Reduced padding for mobile */
            overflow-x: auto;
            min-height: 600px;
        }
        .round {
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            min-width: 180px; /* Adjusted min-width for responsiveness */
            width: 220px; /* Default width for larger screens */
            margin: 0 8px; /* Reduced margin for mobile */
        }

        @media (min-width: 768px) { /* Medium screens and up */
            .round {
                min-width: 250px;
                width: 250px;
                margin: 0 20px;
            }
        }

        .match {
            position: relative;
            display: flex;
            flex-direction: column;
            justify-content: center;
            margin: 12px 0; /* Adjusted margin */
            flex-grow: 1;
        }
        .match-pair {
             display: flex;
             flex-direction: column;
             justify-content: center;
             background-color: #fff;
             border-radius: 8px;
             box-shadow: 0 2px 4px rgba(0,0,0,0.05);
             padding: 6px; /* Reduced padding */
             min-height: 70px; /* Reduced min-height */
        }
        .competitor {
            padding: 6px; /* Reduced padding */
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid #e0e0e0;
            margin: 2px 0; /* Reduced margin */
            text-transform: capitalize;
            font-size: 0.85rem; /* Adjusted font size */
        }
        @media (min-width: 768px) {
            .competitor {
                padding: 10px;
                margin: 5px 0;
                font-size: 1rem;
            }
        }

        .competitor:not(.winner):not(.loser):hover {
            background-color: #f0f8ff;
            border-color: #4a90e2;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        .competitor.winner {
            background-color: #4CAF50;
            color: white;
            font-weight: bold;
            border-color: #4CAF50;
        }
        .competitor.loser {
            background-color: #fbe9e7;
            color: #9e9e9e;
            text-decoration: line-through;
            opacity: 0.7;
        }
        .competitor.placeholder {
            background-color: #f5f5f5;
            color: #bdbdbd;
            cursor: default;
            text-align: center;
        }
        .vs-separator {
            text-align: center;
            font-weight: bold;
            color: #d32f2f;
            font-family: 'Lora', serif;
            margin: 2px 0;
            font-size: 0.75rem; /* Adjusted font size */
        }
        @media (min-width: 768px) {
            .vs-separator {
                font-size: 1rem;
            }
        }
        .match-connector {
            position: absolute;
            right: -15px; /* Adjusted for smaller margins */
            top: 50%;
            width: 15px; /* Adjusted width */
            height: 2px;
            background-color: #bdbdbd;
        }
        .round-connector {
            position: absolute;
            right: -23px; /* Adjusted for smaller margins */
            width: 2px;
            background-color: #bdbdbd;
        }
        .final .match-connector, .final .round-connector {
            display: none;
        }
        .winner-trophy {
            text-align: center;
            animation: fadeIn 1s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }

        /* Loading Spinner */
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #4CAF50;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Quiz Specific Styles */
        .question-options button {
            background-color: #f0f8ff;
            border: 1px solid #4a90e2;
            color: #4a4a4a;
            padding: 10px 15px;
            margin: 5px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            width: 100%;
            text-align: left;
        }
        .question-options button:hover:not(.selected):not(.correct):not(.incorrect) {
            background-color: #e0f0ff;
        }
        .question-options button.selected {
            background-color: #a0d0ff;
            border-color: #2a70c2;
            font-weight: bold;
        }
        .question-options button.correct {
            background-color: #4CAF50;
            color: white;
            font-weight: bold;
            border-color: #4CAF50;
        }
        .question-options button.incorrect {
            background-color: #f44336;
            color: white;
            font-weight: bold;
            border-color: #f44336;
        }
        .player-score-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background-color: #f5f5f5;
            border-radius: 6px;
            margin-bottom: 5px;
            font-size: 0.9rem;
        }
        .player-score-item.current-player {
            background-color: #e0f7fa;
            border: 1px solid #00bcd4;
        }
        .player-score-item .player-name {
            font-weight: bold;
        }
        .player-score-item .player-score {
            font-weight: bold;
            color: #3f51b5;
        }
        .timer-bar-container {
            width: 100%;
            background-color: #e0e0e0;
            border-radius: 5px;
            height: 10px;
            margin-top: 10px;
            overflow: hidden;
        }
        .timer-bar {
            height: 100%;
            background-color: #4CAF50;
            width: 100%;
            transition: width linear;
        }
    </style>
</head>
<body class="bg-gray-50">

    <div class="container mx-auto p-4 md:p-8">
        <header class="text-center mb-8">
            <h1 class="text-4xl md:text-5xl font-bold title-font text-red-800">Torneo dei Piatti Italiani</h1>
            <p class="text-lg text-gray-600 mt-2">Scegli il tuo piatto preferito in ogni scontro per incoronare il campione!</p>
            <p class="text-sm text-gray-500 mt-1" id="user-id-display"></p>
        </header>

        <!-- Loading Screen -->
        <div id="loading-screen" class="flex flex-col items-center justify-center min-h-[400px] bg-white p-8 rounded-lg shadow-lg hidden">
            <div class="spinner mb-4"></div>
            <p class="text-xl text-gray-700">Caricamento...</p>
        </div>

        <!-- Main Menu Screen -->
        <div id="main-menu-screen" class="flex flex-col items-center justify-center min-h-[400px] bg-white p-8 rounded-lg shadow-lg">
            <h2 class="text-3xl font-bold title-font text-red-700 mb-6">Scegli la Modalit√† di Gioco</h2>
            <button id="start-solo-tournament-button" class="bg-green-600 text-white font-bold py-3 px-8 rounded-lg shadow-md hover:bg-green-700 transition-colors duration-300 text-lg mb-4">Inizia Torneo (Singolo)</button>
            <button id="start-multiplayer-quiz-button" class="bg-blue-600 text-white font-bold py-3 px-8 rounded-lg shadow-md hover:bg-blue-700 transition-colors duration-300 text-lg">Inizia Quiz Multiplayer</button>
        </div>

        <!-- Solo Tournament Start Screen -->
        <div id="solo-start-screen" class="flex flex-col items-center justify-center min-h-[400px] bg-white p-8 rounded-lg shadow-lg hidden">
            <h2 class="text-3xl font-bold title-font text-red-700 mb-6">Configura il tuo Torneo (Singolo)</h2>
            
            <div class="mb-6 w-full max-w-sm">
                <label for="category-select" class="block text-gray-700 text-sm font-bold mb-2">Seleziona Categoria:</label>
                <select id="category-select" class="shadow border rounded-lg w-full py-3 px-4 text-gray-700 leading-tight focus:outline-none focus:shadow-outline bg-gray-100 border-gray-300">
                    <!-- Options populated by JavaScript -->
                </select>
            </div>

            <div class="mb-8 w-full max-w-sm">
                <label for="size-select" class="block text-gray-700 text-sm font-bold mb-2">Numero di Partecipanti:</label>
                <select id="size-select" class="shadow border rounded-lg w-full py-3 px-4 text-gray-700 leading-tight focus:outline-none focus:shadow-outline bg-gray-100 border-gray-300">
                    <option value="8">8</option>
                    <option value="16" selected>16</option>
                    <option value="32">32</option>
                    <option value="64">64</option>
                </select>
                <p id="size-warning" class="text-sm text-red-500 mt-2 hidden">Attenzione: Non ci sono abbastanza elementi per questa dimensione del torneo nella categoria selezionata.</p>
            </div>

            <button id="start-tournament-button" class="bg-green-600 text-white font-bold py-3 px-8 rounded-lg shadow-md hover:bg-green-700 transition-colors duration-300 text-lg">Inizia Torneo</button>

            <hr class="my-8 w-full max-w-md border-t-2 border-gray-200">

            <h3 class="text-2xl font-bold title-font text-gray-700 mb-4">Genera Nuova Lista con AI ‚ú®</h3>
            <div class="mb-4 w-full max-w-sm">
                <label for="ai-category-prompt" class="block text-gray-700 text-sm font-bold mb-2">Tipo di elementi da generare:</label>
                <input type="text" id="ai-category-prompt" placeholder="Es: citt√† italiane, sport olimpici" class="shadow appearance-none border rounded-lg w-full py-3 px-4 text-gray-700 leading-tight focus:outline-none focus:shadow-outline bg-gray-100 border-gray-300"/>
            </div>
            <button id="generate-list-button" class="bg-purple-600 text-white font-bold py-2 px-6 rounded-lg shadow-md hover:bg-purple-700 transition-colors duration-300">Genera Nuova Lista ‚ú®</button>
            <p id="generate-feedback" class="text-sm mt-2 hidden"></p>
            <div id="generate-spinner" class="spinner mt-4 hidden"></div>
        </div>

        <!-- Solo Tournament Container -->
        <div id="solo-tournament-container" class="hidden">
            <main id="tournament-bracket" class="bracket-container">
                <!-- Le colonne del torneo verranno generate qui da JavaScript -->
            </main>

            <div id="winner-display" class="text-center mt-12"></div>
            
            <footer class="text-center mt-12">
                <button id="reset-solo-button" class="bg-red-700 text-white font-bold py-2 px-6 rounded-lg shadow-md hover:bg-red-800 transition-colors duration-300">Torna al Menu Principale</button>
            </footer>
        </div>

        <!-- Multiplayer Quiz Setup Screen -->
        <div id="multiplayer-setup-screen" class="flex flex-col items-center justify-center min-h-[400px] bg-white p-8 rounded-lg shadow-lg hidden">
            <h2 class="text-3xl font-bold title-font text-blue-700 mb-6">Configura il tuo Quiz Multiplayer</h2>
            
            <div class="mb-4 w-full max-w-sm">
                <label for="player-nickname" class="block text-gray-700 text-sm font-bold mb-2">Il tuo Nickname:</label>
                <input type="text" id="player-nickname" placeholder="Inserisci il tuo nome" class="shadow appearance-none border rounded-lg w-full py-3 px-4 text-gray-700 leading-tight focus:outline-none focus:shadow-outline bg-gray-100 border-gray-300"/>
            </div>

            <div class="mb-6 w-full max-w-sm">
                <label for="quiz-category-select" class="block text-gray-700 text-sm font-bold mb-2">Seleziona Categoria Quiz:</label>
                <select id="quiz-category-select" class="shadow border rounded-lg w-full py-3 px-4 text-gray-700 leading-tight focus:outline-none focus:shadow-outline bg-gray-100 border-gray-300">
                    <!-- Options populated by JavaScript -->
                </select>
            </div>

            <div class="mb-8 w-full max-w-sm">
                <label for="quiz-size-select" class="block text-gray-700 text-sm font-bold mb-2">Numero di Domande (max 16):</label>
                <select id="quiz-size-select" class="shadow border rounded-lg w-full py-3 px-4 text-gray-700 leading-tight focus:outline-none focus:shadow-outline bg-gray-100 border-gray-300">
                    <option value="4">4</option>
                    <option value="8">8</option>
                    <option value="16" selected>16</option>
                </select>
                <p id="quiz-size-warning" class="text-sm text-red-500 mt-2 hidden">Attenzione: Non ci sono abbastanza elementi per generare questa quantit√† di domande nella categoria selezionata.</p>
            </div>

            <button id="create-room-button" class="bg-blue-600 text-white font-bold py-3 px-8 rounded-lg shadow-md hover:bg-blue-700 transition-colors duration-300 text-lg mb-4">Crea Stanza</button>
            
            <hr class="my-8 w-full max-w-md border-t-2 border-gray-200">

            <div class="mb-4 w-full max-w-sm">
                <label for="room-id-input" class="block text-gray-700 text-sm font-bold mb-2">ID Stanza:</label>
                <input type="text" id="room-id-input" placeholder="Inserisci ID Stanza" class="shadow appearance-none border rounded-lg w-full py-3 px-4 text-gray-700 leading-tight focus:outline-none focus:shadow-outline bg-gray-100 border-gray-300"/>
            </div>
            <button id="join-room-button" class="bg-indigo-600 text-white font-bold py-3 px-8 rounded-lg shadow-md hover:bg-indigo-700 transition-colors duration-300 text-lg">Unisciti a Stanza</button>
            <p id="room-feedback" class="text-sm mt-2 hidden"></p>
            <div id="room-spinner" class="spinner mt-4 hidden"></div>

            <footer class="text-center mt-12">
                <button id="back-to-main-menu-button" class="bg-gray-500 text-white font-bold py-2 px-6 rounded-lg shadow-md hover:bg-gray-600 transition-colors duration-300">Torna al Menu Principale</button>
            </footer>
        </div>

        <!-- Quiz Lobby Screen -->
        <div id="quiz-lobby-screen" class="flex flex-col items-center justify-center min-h-[400px] bg-white p-8 rounded-lg shadow-lg hidden">
            <h2 class="text-3xl font-bold title-font text-blue-700 mb-6">Lobby della Stanza Quiz</h2>
            <p class="text-xl text-gray-700 mb-4">ID Stanza: <span id="lobby-room-id" class="font-bold text-blue-800"></span></p>
            <p class="text-md text-gray-600 mb-4">(Condividi questo ID con i tuoi amici)</p>

            <h3 class="text-2xl font-bold title-font text-gray-700 mb-4">Giocatori Connessi:</h3>
            <ul id="players-list" class="list-disc list-inside text-gray-800 mb-8 max-w-sm w-full">
                <!-- Players will be listed here -->
            </ul>

            <button id="start-quiz-button" class="bg-green-600 text-white font-bold py-3 px-8 rounded-lg shadow-md hover:bg-green-700 transition-colors duration-300 text-lg hidden">Inizia Quiz</button>
            <p id="lobby-feedback" class="text-sm mt-2 hidden"></p>
            <div id="lobby-spinner" class="spinner mt-4 hidden"></div>

            <footer class="text-center mt-12">
                <button id="leave-room-button" class="bg-red-700 text-white font-bold py-2 px-6 rounded-lg shadow-md hover:bg-red-800 transition-colors duration-300">Abbandona Stanza</button>
            </footer>
        </div>

        <!-- Quiz Game Screen -->
        <div id="quiz-game-screen" class="flex flex-col items-center justify-center min-h-[400px] bg-white p-8 rounded-lg shadow-lg hidden">
            <h2 class="text-2xl font-bold title-font text-blue-700 mb-4">Quiz in Corso</h2>
            <p class="text-lg text-gray-600 mb-4">Domanda <span id="current-question-number"></span> di <span id="total-questions"></span></p>
            
            <div class="w-full max-w-xl bg-gray-100 p-6 rounded-lg shadow-inner mb-6">
                <p id="question-text" class="text-xl font-semibold text-gray-800 mb-4 text-center"></p>
                <div class="timer-bar-container">
                    <div id="timer-bar" class="timer-bar"></div>
                </div>
            </div>

            <div id="question-options" class="w-full max-w-xl grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                <!-- Options populated by JavaScript -->
            </div>
            <p id="answer-feedback" class="text-md mt-2 hidden"></p>
            <div id="quiz-spinner" class="spinner mt-4 hidden"></div>

            <div class="w-full max-w-xl bg-white p-4 rounded-lg shadow-md">
                <h3 class="text-xl font-bold text-gray-700 mb-3">Punteggi:</h3>
                <ul id="quiz-players-scores" class="w-full">
                    <!-- Player scores will be listed here -->
                </ul>
            </div>

            <button id="next-question-button" class="bg-green-600 text-white font-bold py-3 px-8 rounded-lg shadow-md hover:bg-green-700 transition-colors duration-300 text-lg mt-8 hidden">Prossima Domanda</button>
            <button id="end-quiz-button" class="bg-red-600 text-white font-bold py-2 px-6 rounded-lg shadow-md hover:bg-red-700 transition-colors duration-300 mt-4 hidden">Termina Quiz</button>
        </div>

        <!-- Quiz Results Screen -->
        <div id="quiz-results-screen" class="flex flex-col items-center justify-center min-h-[400px] bg-white p-8 rounded-lg shadow-lg hidden">
            <h2 class="text-3xl font-bold title-font text-blue-700 mb-6">Risultati Quiz!</h2>
            <h3 class="text-2xl font-bold text-gray-800 mb-4">Classifica Finale:</h3>
            <ul id="final-scores-list" class="list-none text-gray-800 mb-8 w-full max-w-sm">
                <!-- Final scores will be listed here -->
            </ul>
            <button id="play-again-button" class="bg-green-600 text-white font-bold py-3 px-8 rounded-lg shadow-md hover:bg-green-700 transition-colors duration-300 text-lg mb-4">Gioca Ancora</button>
            <button id="return-to-main-menu-quiz-end" class="bg-gray-500 text-white font-bold py-2 px-6 rounded-lg shadow-md hover:bg-gray-600 transition-colors duration-300">Torna al Menu Principale</button>
        </div>

    </div>

    <script>
        // Ensure Firebase is loaded before running main script
        window.addEventListener('load', async () => {
            if (typeof window.firebase === 'undefined') {
                console.error("Firebase SDK not loaded. Please ensure the module script runs correctly.");
                document.getElementById('loading-screen').innerHTML = '<p class="text-red-500">Errore: Firebase non caricato. Ricarica la pagina.</p>';
                return;
            }

            const { auth, db, signInAnonymously, signInWithCustomToken, onAuthStateChanged, setDoc, collection, query, onSnapshot, updateDoc, arrayUnion, arrayRemove, deleteDoc, doc, getDoc, serverTimestamp } = window.firebase;

            // --- DATA ---
            // Initial built-in data
            let dishData = {
                primi: [
                    "tagliatelle al ragu", "pasta e fagioli", "ravioli ricotta e spinaci", "riso patate e cozze",
                    "zuppa di pesce", "spaghetti alla puttanesca", "penne all'arrabbiata", "pasta patate e provola",
                    "lasagne al rag√π", "risotto alla zucca", "gnocchi alla sorrentina", "spaghetti burro e parmigiano",
                    "risotto giallo", "canederli", "tortellini panna e prosciutto", "pennette con salmone",
                    "spaghetti con le vongole", "tortelli cremaschi", "pappa al pomodoro", "ribollita",
                    "cacio e pepe", "spaghetti aglio e olio", "cannelloni ricotta e spinaci", "spaghetti all'assassina",
                    "carbonara", "agnolotti", "linguine con astice", "tagliolini burro e limone",
                    "pappardelle al cinghiale", "pasta alla norma", "pasta al forno", "pici all'aglione",
                    "tortellini in brodo", "orechiette broccoli e alici", "velluttata di verdure", "spaghetti alla nerano",
                    "parmigiana di melanzane", "risotto ai funghi", "spaghetti con polpette", "anelletti al forno con rag√π e piselli",
                    "trofie al pesto", "pasta con le sarde", "gnocchi alla romana", "zuppa di cipolle",
                    "spaghetti al pomodoro", "orecchiette cime di rapa", "tagliolini con tartufo", "stelline in brodo",
                    "amatriciana", "fusilli alla trapanese", "linguine al nero di seppia", "minestrone con crostini",
                    "pizzoccheri", "gricia", "gnocchi al gorgonzola", "pasta al tonno", "spazzle burro e salvia",
                    "pasta allo scoglio", "pasta e lenticchie", "spaghetti con la bottarga", "pasta ai peperoni cruschi"
                ].map(d => d.toLowerCase().trim()).filter(d => d),

                secondiEContorni: [
                    "Polpette al sugo", "Polpo e patate", "Calamari ripieni", "Polpettone", "Brasato", "Filetto al pepe verde",
                    "Pollo alla cacciatora", "Nervetti", "Vitello tonnato", "Saltimbocca", "Faraona ripiena", "Seppie in umido",
                    "Spezzatino", "Baccal√† mantecato", "Cotechino bollito", "Stinco di maiale", "Fiorentina", "Scaloppine",
                    "Impepata di cozze", "Coniglio alla ligure", "Ossobuco alla milanese", "Orata al forno", "Bollito con salse",
                    "Anatra all'arancia", "Cotoletta alla milanese", "Costolette d'agnello", "Trippa alla romana", "Alici fritte",
                    "Fritto misto", "Grigliata di pesce", "Braciole al sugo", "Peperoni ripieni", "Polenta e cinghiale", "Cacciucco",
                    "Fagioli con le cotiche", "Fettine panate", "Arrosto di vitello", "Fegato alla veneziana", "Capesante gratinate",
                    "Stracotto d'asino", "Pollo arrosto", "Crocchette di patate", "Guancia di maiale brasata", "Lumache aglio e prezzemolo",
                    "Costine di maiale", "Verdure grigliate", "Salmone in crosta", "Merluzzo fritto", "Patate al forno", "Torta di patate",
                    "Pur√® di patate", "Carne alla pizzaiola", "Patatine fritte", "Polenta concia", "Ratatouille", "Carciofi alla giudia",
                    "Caponata", "Peperonata", "Funghi trifolati", "Finocchi gratinati", "Cipolle caramellate", "Frittata di cipolle",
                    "Zucca al forno", "Cicoria ripassata"
                ].map(d => d.toLowerCase().trim()).filter(d => d),

                dolci: [
                    "Tiramis√π", "Cannolo siciliano", "Delizia al limone", "Sorbetto al limone", "Crostata alla marmellata",
                    "Torta caprese", "Cassata", "Torta pesca e amaretti", "Salame al cioccolato", "Pandoro", "Colomba",
                    "Bertolina", "Torta pere e cioccolato", "Mousse tre cioccolati", "Mele cotte con cannella", "Sfogliatella riccia",
                    "Strudel", "Maritozzo", "Seadas", "Panettone", "Pasticciotto leccese", "Zabaione", "Struffoli", "Millefoglie",
                    "Torta tenerina", "Zeppole", "Torta diplomatica", "Tortino al cioccolato", "Graffe", "Cartellate pugliesi",
                    "Ciambellone", "Chiacchiere / Frittelle", "Meringata", "Torta delle rose", "Castagnaccio", "Panna cotta",
                    "Semifreddo al caff√®", "Bonet", "Pane dei morti", "Torta di mele", "Sospiri", "Torta paradiso",
                    "Torta ricotta e cioccolato", "Bab√†", "Tartufo (bianco/nero)", "Torrone", "Mostaccioli",
                    "Crostata di frutta con crema pasticcera", "Castagnole / Tortellli", "Piadina con la nutella", "Croccante alle mandorle",
                    "Torta della nonna", "Pastiera napoletana", "Torta fredda allo yogurt", "Panpepato", "Sbrisolona", "Zuppa inglese",
                    "Profiteroles", "Torta mimosa", "Gelato artigianale", "Torta cocco e cioccolato", "Creme caramel", "Torta alla carota"
                ].map(d => d.toLowerCase().trim()).filter(d => d),

                biscotti: [
                    "Macine", "Galletti", "Scacchieri", "Baiocchi al pistacchio", "Pan di stelle", "Baiocchi", "Oro Saiwa",
                    "Molinetti", "Abbracci", "Digestive", "Tarallucci", "Girotondi", "Nascondini", "Settembrini", "Campagnole",
                    "Batticuori", "Cuor di mela", "Pannocchie", "Ritornelli", "Pavesini", "Gocciole", "Canestrelli", "Rigoli",
                    "Gocciole dark/caramello", "Plasmon", "Tenerezze al limone", "Primizie", "Krumiri", "Ringo", "GranCereale",
                    "Buoni cos√¨", "Nonnine Doria", "Bucaneve", "Oreo", "Grisb√¨ (nocciola, cioccolato, crema, limone)",
                    "Zuppalatte Colussi", "Nutella Biscuits", "Zalet", "Biscotti Atene", "Ancorauno Tre Marie",
                    "Wafer Loacker (cacao/latte)", "Butter cookie Royal Danish", "Gran Turchese", "Biscotti allo zenzero Ikea",
                    "Lotus", "Mikado", "Kinder Cards", "Ciambelle Balocco", "Cookies Milka", "Amaretti Balocco",
                    "Zuppole Balocco", "Girandole Balocco", "Sfogliatine Balocco", "OroCiok", "Savoiardi Balocco",
                    "Oswego Colussi", "Cantuccini"
                ].map(d => d.toLowerCase().trim().replace(/"/g, '')).filter(d => d),

                attori: [
                    "Brad Pitt", "Tom Cruise", "George Clooney", "Richard Gere", "Jake Gyllenhal", "Ryan Gosling",
                    "jamie foxx", "michael b jordan", "Tom Hardy", "Jacob Elordi", "javier bardem", "Elio Germano",
                    "Ben Affleck", "johnny depp", "Bradley Cooper", "Luca Marinelli", "Adrien Brody",
                    "Leonardo di Caprio", "Sam Caflin", "Alessandro Borghi", "Paul Newman", "Cilian Murphy",
                    "Robert Pattinson", "Jude Law", "James Deen", "Robert Downey Jr.", "Timoth√©e Chalamet",
                    "robert redford", "Christian Bale", "Matthew McConnaguyeehgahgurnafdha", "Viggo Mortensen",
                    "Ashton Kutcher", "Hugh Jacckkkkmannn", "Henry Cavill", "Oscar Isaac", "Lee Pace",
                    "Matt Damon", "Aaron Taylor-Johnson", "Armie Hammer", "Jeremy White", "Sean Penn",
                    "Chris Hemsworth", "Harrison Ford", "Edward Norton", "Omar Sy", "Keanu Reeves",
                    "Chris Hemsword", "Bruce Willis", "Djimon Hounsou.", "Benicio Del Toro", "Adam Driver",
                    "Jason Statham", "Patrick Dempsey", "Vincent Cassel", "Jeffrey Dean Morgan", "Adam Brody",
                    "Benedict Cumberbatch", "Andrew Garfield", "Matt Bomer", "Ryan Reynolds"
                ].map(d => d.toLowerCase().trim().replace(/"/g, '')).filter(d => d),

            };
            
            const roundTitles = ["Ottavi di Finale", "Quarti di Finale", "Semifinali", "Finale"];

            // --- DOM Elements ---
            const loadingScreen = document.getElementById('loading-screen');
            const mainMenuScreen = document.getElementById('main-menu-screen');
            const soloStartScreen = document.getElementById('solo-start-screen');
            const soloTournamentContainer = document.getElementById('solo-tournament-container');
            const multiplayerSetupScreen = document.getElementById('multiplayer-setup-screen');
            const quizLobbyScreen = document.getElementById('quiz-lobby-screen');
            const quizGameScreen = document.getElementById('quiz-game-screen');
            const quizResultsScreen = document.getElementById('quiz-results-screen');

            const categorySelect = document.getElementById('category-select'); // Solo tournament category
            const sizeSelect = document.getElementById('size-select'); // Solo tournament size
            const startSoloTournamentButton = document.getElementById('start-solo-tournament-button');
            const startTournamentButton = document.getElementById('start-tournament-button'); // Solo tournament start
            const resetSoloButton = document.getElementById('reset-solo-button'); // Solo tournament reset
            const sizeWarning = document.getElementById('size-warning'); // Solo tournament warning

            const aiCategoryPromptInput = document.getElementById('ai-category-prompt');
            const generateListButton = document.getElementById('generate-list-button');
            const generateFeedback = document.getElementById('generate-feedback');
            const generateSpinner = document.getElementById('generate-spinner');

            const bracket = document.getElementById('tournament-bracket'); // Solo tournament bracket
            const winnerDisplay = document.getElementById('winner-display'); // Solo tournament winner

            // Multiplayer Quiz Elements
            const startMultiplayerQuizButton = document.getElementById('start-multiplayer-quiz-button');
            const playerNicknameInput = document.getElementById('player-nickname');
            const quizCategorySelect = document.getElementById('quiz-category-select');
            const quizSizeSelect = document.getElementById('quiz-size-select');
            const quizSizeWarning = document.getElementById('quiz-size-warning');
            const createRoomButton = document.getElementById('create-room-button');
            const roomIdInput = document.getElementById('room-id-input');
            const joinRoomButton = document.getElementById('join-room-button');
            const roomFeedback = document.getElementById('room-feedback');
            const roomSpinner = document.getElementById('room-spinner');
            const backToMainMenuButton = document.getElementById('back-to-main-menu-button');

            // Quiz Lobby Elements
            const lobbyRoomIdDisplay = document.getElementById('lobby-room-id');
            const playersList = document.getElementById('players-list');
            const startQuizButton = document.getElementById('start-quiz-button');
            const leaveRoomButton = document.getElementById('leave-room-button');
            const lobbyFeedback = document.getElementById('lobby-feedback');
            const lobbySpinner = document.getElementById('lobby-spinner');

            // Quiz Game Elements
            const currentQuestionNumberDisplay = document.getElementById('current-question-number');
            const totalQuestionsDisplay = document.getElementById('total-questions');
            const questionTextDisplay = document.getElementById('question-text');
            const questionOptionsContainer = document.getElementById('question-options');
            const answerFeedbackDisplay = document.getElementById('answer-feedback');
            const quizSpinner = document.getElementById('quiz-spinner');
            const quizPlayersScoresList = document.getElementById('quiz-players-scores');
            const nextQuestionButton = document.getElementById('next-question-button');
            const endQuizButton = document.getElementById('end-quiz-button');
            const timerBar = document.getElementById('timer-bar');

            // Quiz Results Elements
            const finalScoresList = document.getElementById('final-scores-list');
            const playAgainButton = document.getElementById('play-again-button');
            const returnToMainMenuQuizEndButton = document.getElementById('return-to-main-menu-quiz-end');

            const userIdDisplay = document.getElementById('user-id-display');

            let currentUserId = null;
            let currentUserName = "Giocatore Anonimo"; // Default nickname
            const appId = window.__app_id;
            let currentRoomId = null;
            let unsubscribeRoomListener = null; // To manage Firestore real-time listener

            const QUESTION_TIME_LIMIT = 15; // seconds
            let questionTimerInterval = null;

            // --- UTILITY FUNCTIONS ---
            function shuffle(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }

            function generateRoomId() {
                return Math.random().toString(36).substring(2, 8).toUpperCase(); // 6-character alphanumeric
            }

            function showScreen(screenId) {
                const screens = [loadingScreen, mainMenuScreen, soloStartScreen, soloTournamentContainer, multiplayerSetupScreen, quizLobbyScreen, quizGameScreen, quizResultsScreen];
                screens.forEach(screen => {
                    if (screen.id === screenId) {
                        screen.classList.remove('hidden');
                    } else {
                        screen.classList.add('hidden');
                    }
                });
            }

            // --- SOLO TOURNAMENT LOGIC ---
            function validateTournamentSize(selectElement, warningElement, buttonElement, categoryKey) {
                const selectedCategory = selectElement.value;
                if (!dishData.hasOwnProperty(selectedCategory)) {
                    warningElement.textContent = "Categoria selezionata non valida.";
                    warningElement.classList.remove('hidden');
                    buttonElement.disabled = true;
                    buttonElement.classList.add('opacity-50', 'cursor-not-allowed');
                    return;
                }

                const selectedSize = parseInt(selectElement.value);
                const availableItems = dishData[selectedCategory].length;

                if (selectedSize > availableItems) {
                    warningElement.textContent = `Attenzione: Non ci sono abbastanza elementi (${availableItems}) per questa dimensione del torneo (${selectedSize}) nella categoria selezionata.`;
                    warningElement.classList.remove('hidden');
                    buttonElement.disabled = true;
                    buttonElement.classList.add('opacity-50', 'cursor-not-allowed');
                } else {
                    warningElement.classList.add('hidden');
                    buttonElement.disabled = false;
                    buttonElement.classList.remove('opacity-50', 'cursor-not-allowed');
                }
            }

            function createSoloTournament(items, tournamentSize) {
                bracket.innerHTML = '';
                winnerDisplay.innerHTML = '';

                const competitors = shuffle([...items]).slice(0, tournamentSize);
                let numberOfRounds = Math.log2(tournamentSize);

                for (let i = 0; i < numberOfRounds; i++) {
                    const roundDiv = document.createElement('div');
                    roundDiv.className = `round round-${i+1}`;
                    if (i === numberOfRounds - 1) roundDiv.classList.add('final');

                    const roundTitle = document.createElement('h2');
                    roundTitle.className = 'text-xl md:text-2xl font-bold text-center mb-4 md:mb-6 title-font text-red-700';
                    roundTitle.textContent = roundTitles[i];
                    roundDiv.appendChild(roundTitle);
                    
                    const matchesInRound = tournamentSize / Math.pow(2, i+1);

                    for (let j = 0; j < matchesInRound; j++) {
                        const matchDiv = document.createElement('div');
                        matchDiv.className = 'match';
                        matchDiv.dataset.round = i;
                        matchDiv.dataset.match = j;

                        const matchPair = document.createElement('div');
                        matchPair.className = 'match-pair';

                        const competitor1 = document.createElement('div');
                        competitor1.className = 'competitor';
                        competitor1.dataset.competitorId = `r${i}m${j}c1`;

                        const vs = document.createElement('div');
                        vs.className = 'vs-separator';
                        vs.textContent = 'vs';

                        const competitor2 = document.createElement('div');
                        competitor2.className = 'competitor';
                        competitor2.dataset.competitorId = `r${i}m${j}c2`;

                        if (i === 0) {
                            competitor1.textContent = competitors[j * 2];
                            competitor2.textContent = competitors[j * 2 + 1];
                            competitor1.addEventListener('click', handleSoloMatchClick);
                            competitor2.addEventListener('click', handleSoloMatchClick);
                        } else {
                            competitor1.textContent = 'In attesa...';
                            competitor2.textContent = 'In attesa...';
                            competitor1.classList.add('placeholder');
                            competitor2.classList.add('placeholder');
                        }

                        matchPair.appendChild(competitor1);
                        matchPair.appendChild(vs);
                        matchPair.appendChild(competitor2);
                        matchDiv.appendChild(matchPair);
                        
                        // Add connectors
                        if (i < numberOfRounds - 1) {
                            const connector = document.createElement('div');
                            connector.className = 'match-connector';
                            matchDiv.appendChild(connector);

                            const baseMatchHeight = 70;
                            const matchMargin = 24;
                            const roundHeight = (baseMatchHeight + matchMargin) * Math.pow(2, i);
                            const connectorHeight = roundHeight - baseMatchHeight;

                            if (j % 2 === 0) {
                                const roundConnector = document.createElement('div');
                                roundConnector.className = 'round-connector';
                                roundConnector.style.height = `${connectorHeight + baseMatchHeight}px`;
                                roundConnector.style.top = `calc(50% - ${connectorHeight / 2}px)`;
                                matchDiv.appendChild(roundConnector);
                            }
                        }
                        
                        roundDiv.appendChild(matchDiv);
                    }
                    bracket.appendChild(roundDiv);
                }
            }

            function handleSoloMatchClick(event) {
                const selected = event.currentTarget;
                const matchPair = selected.parentElement;
                
                if (matchPair.dataset.winner || selected.classList.contains('placeholder')) return;

                const competitors = Array.from(matchPair.getElementsByClassName('competitor'));
                const winner = selected;
                const loser = competitors.find(c => c !== winner);

                winner.classList.add('winner');
                loser.classList.add('loser');
                matchPair.dataset.winner = winner.textContent;

                advanceSoloWinner(winner);
            }

            function advanceSoloWinner(winner) {
                const matchPair = winner.parentElement;
                const matchDiv = matchPair.parentElement;
                const round = parseInt(matchDiv.dataset.round);
                const match = parseInt(matchDiv.dataset.match);

                const nextRound = round + 1;
                const nextMatch = Math.floor(match / 2);
                const isFirstInNextPair = match % 2 === 0;

                const nextMatchCompetitorSlotQuery = isFirstInNextPair ?
                    `[data-competitor-id="r${nextRound}m${nextMatch}c1"]` :
                    `[data-competitor-id="r${nextRound}m${nextMatch}c2"]`;

                const nextSlot = bracket.querySelector(nextMatchCompetitorSlotQuery);

                if (nextSlot) {
                    nextSlot.textContent = winner.textContent;
                    nextSlot.classList.remove('placeholder');

                    const opponentSlotQuery = isFirstInNextPair ?
                        `[data-competitor-id="r${nextRound}m${nextMatch}c2"]` :
                        `[data-competitor-id="r${nextRound}m${nextMatch}c1"]`;
                    const opponentSlot = bracket.querySelector(opponentSlotQuery);

                    if (opponentSlot && !opponentSlot.classList.contains('placeholder')) {
                        nextSlot.addEventListener('click', handleSoloMatchClick);
                        opponentSlot.addEventListener('click', handleSoloMatchClick);
                    }
                } else {
                    displaySoloWinner(winner.textContent);
                }
            }

            function displaySoloWinner(name) {
                const winnerDisplay = document.getElementById('winner-display');
                winnerDisplay.innerHTML = `
                    <div class="winner-trophy">
                        <h2 class="text-2xl md:text-3xl font-bold title-font text-amber-600">Vincitore del Torneo!</h2>
                        <p class="text-4xl md:text-5xl font-bold my-4 text-red-800" style="text-transform: capitalize;">${name}</p>
                        <div class="text-6xl md:text-7xl">üèÜ</div>
                    </div>
                `;
            }

            // --- FIREBASE & DATA MANAGEMENT ---
            async function saveCategoryItemsToFirestore(categoryName, itemsArray) {
                const uniqueItems = [...new Set(itemsArray)];
                if (currentUserId) {
                    try {
                        const categoryRef = doc(db, `artifacts/${appId}/users/${currentUserId}/categories`, categoryName);
                        await setDoc(categoryRef, {
                            name: categoryName,
                            items: uniqueItems
                        });
                        console.log(`Categoria "${categoryName}" salvata con successo su Firestore.`);
                    } catch (e) {
                        console.error("Errore durante il salvataggio della categoria su Firestore: ", e);
                    }
                } else {
                    dishData[categoryName] = uniqueItems;
                    console.warn(`Categoria "${categoryName}" aggiunta localmente (utente non autenticato).`);
                }
                updateCategorySelects();
            }

            function updateCategorySelects() {
                const selects = [categorySelect, quizCategorySelect];
                selects.forEach(selectElement => {
                    const currentSelectedValue = selectElement.value;
                    selectElement.innerHTML = '';
                    for (const key in dishData) {
                        if (dishData.hasOwnProperty(key) && dishData[key].length > 0) {
                            const option = document.createElement('option');
                            option.value = key;
                            option.textContent = key.charAt(0).toUpperCase() + key.slice(1).replace(/([A-Z])/g, ' $1');
                            selectElement.appendChild(option);
                        }
                    }
                    if (dishData.hasOwnProperty(currentSelectedValue)) {
                        selectElement.value = currentSelectedValue;
                    } else if (Object.keys(dishData).length > 0) {
                        selectElement.value = Object.keys(dishData)[0];
                    } else {
                        selectElement.innerHTML = '<option value="">Nessuna categoria disponibile</option>';
                        startButton.disabled = true;
                        startButton.classList.add('opacity-50', 'cursor-not-allowed');
                        createRoomButton.disabled = true;
                        createRoomButton.classList.add('opacity-50', 'cursor-not-allowed');
                    }
                });
                validateTournamentSize(categorySelect, sizeWarning, startTournamentButton, 'solo');
                validateTournamentSize(quizCategorySelect, quizSizeWarning, createRoomButton, 'quiz');
            }

            // --- GEMINI AI INTEGRATION ---
            generateListButton.addEventListener('click', async function() {
                const aiCategoryPrompt = aiCategoryPromptInput.value.trim();
                if (!aiCategoryPrompt) {
                    generateFeedback.textContent = "Inserisci un tipo di elementi da generare (es: citt√† italiane).";
                    generateFeedback.className = "text-sm mt-2 text-red-500";
                    generateFeedback.classList.remove('hidden');
                    return;
                }

                generateFeedback.classList.add('hidden');
                generateSpinner.classList.remove('hidden');
                generateListButton.disabled = true;
                generateListButton.classList.add('opacity-50', 'cursor-not-allowed');

                try {
                    const prompt = `Genera una lista di 16 ${aiCategoryPrompt} famosi. Rispondi in formato JSON, un array di stringhe, dove ogni stringa √® il nome di un elemento. Non aggiungere altro testo o formattazione oltre al JSON.`;
                    let chatHistory = [];
                    chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                    const payload = {
                        contents: chatHistory,
                        generationConfig: {
                            responseMimeType: "application/json",
                            responseSchema: {
                                type: "ARRAY",
                                items: { "type": "STRING" }
                            }
                        }
                    };
                    const apiKey = "";
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
                    
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    const result = await response.json();

                    if (result.candidates && result.candidates.length > 0 &&
                        result.candidates[0].content && result.candidates[0].content.parts &&
                        result.candidates[0].content.parts.length > 0) {
                        const jsonString = result.candidates[0].content.parts[0].text;
                        const generatedItems = JSON.parse(jsonString);

                        if (generatedItems && Array.isArray(generatedItems) && generatedItems.length > 0) {
                            const newCategoryName = `generati_${aiCategoryPrompt.replace(/\s+/g, '_').toLowerCase()}`;
                            await saveCategoryItemsToFirestore(newCategoryName, generatedItems);
                            
                            generateFeedback.textContent = `Lista di "${aiCategoryPrompt}" generata e aggiunta come categoria "${newCategoryName}"!`;
                            generateFeedback.className = "text-sm mt-2 text-green-600";
                            aiCategoryPromptInput.value = '';
                            categorySelect.value = newCategoryName;
                            quizCategorySelect.value = newCategoryName; // Also update quiz category select
                            validateTournamentSize(categorySelect, sizeWarning, startTournamentButton, 'solo');
                            validateTournamentSize(quizCategorySelect, quizSizeWarning, createRoomButton, 'quiz');
                        } else {
                            generateFeedback.textContent = "L'AI non ha generato una lista valida. Riprova con un prompt diverso.";
                            generateFeedback.className = "text-sm mt-2 text-orange-500";
                        }
                    } else {
                        generateFeedback.textContent = "Impossibile generare la lista. Riprova.";
                        generateFeedback.className = "text-sm mt-2 text-red-500";
                        console.error("Gemini API response structure unexpected for list generation:", result);
                    }
                } catch (error) {
                    generateFeedback.textContent = `Errore durante la generazione della lista: ${error.message}`;
                    generateFeedback.className = "text-sm mt-2 text-red-500";
                    console.error("Error calling Gemini API for list generation:", error);
                } finally {
                    generateSpinner.classList.add('hidden');
                    generateFeedback.classList.remove('hidden');
                    generateListButton.disabled = false;
                    generateListButton.classList.remove('opacity-50', 'cursor-not-allowed');
                }
            });

            async function generateQuizQuestion(item) {
                try {
                    const prompt = `Genera una domanda a risposta multipla con 4 opzioni (A, B, C, D) e la risposta corretta su "${item}". La domanda deve essere interessante e le opzioni plausibili. Rispondi in formato JSON con le seguenti chiavi: "question" (stringa), "options" (array di 4 stringhe), "correctAnswer" (stringa, il testo della risposta corretta). Non aggiungere altro testo o formattazione oltre al JSON.`;
                    let chatHistory = [];
                    chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                    const payload = {
                        contents: chatHistory,
                        generationConfig: {
                            responseMimeType: "application/json",
                            responseSchema: {
                                type: "OBJECT",
                                properties: {
                                    "question": { "type": "STRING" },
                                    "options": { "type": "ARRAY", "items": { "type": "STRING" } },
                                    "correctAnswer": { "type": "STRING" }
                                },
                                propertyOrdering: ["question", "options", "correctAnswer"]
                            }
                        }
                    };
                    const apiKey = "";
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
                    
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    const result = await response.json();

                    if (result.candidates && result.candidates.length > 0 &&
                        result.candidates[0].content && result.candidates[0].content.parts &&
                        result.candidates[0].content.parts.length > 0) {
                        const jsonString = result.candidates[0].content.parts[0].text;
                        const questionData = JSON.parse(jsonString);
                        
                        // Basic validation of the generated question structure
                        if (questionData.question && Array.isArray(questionData.options) && questionData.options.length === 4 && questionData.correctAnswer) {
                            return questionData;
                        } else {
                            console.warn("Generated question has invalid structure:", questionData);
                            return null;
                        }
                    } else {
                        console.error("Gemini API response structure unexpected for question generation:", result);
                        return null;
                    }
                } catch (error) {
                    console.error("Error calling Gemini API for question generation:", error);
                    return null;
                }
            }


            // --- MULTIPLAYER QUIZ LOGIC ---
            async function createRoom() {
                const nickname = playerNicknameInput.value.trim();
                if (!nickname) {
                    roomFeedback.textContent = "Inserisci un nickname per creare una stanza.";
                    roomFeedback.className = "text-sm mt-2 text-red-500";
                    roomFeedback.classList.remove('hidden');
                    return;
                }
                currentUserName = nickname;
                localStorage.setItem('playerNickname', nickname); // Persist nickname

                const category = quizCategorySelect.value;
                const numQuestions = parseInt(quizSizeSelect.value);
                const availableItems = dishData[category];

                if (numQuestions * 2 > availableItems.length) { // Need at least 2 items per question for options
                    roomFeedback.textContent = "Non ci sono abbastanza elementi nella categoria per generare il numero di domande richiesto.";
                    roomFeedback.className = "text-sm mt-2 text-red-500";
                    roomFeedback.classList.remove('hidden');
                    return;
                }

                roomSpinner.classList.remove('hidden');
                roomFeedback.classList.add('hidden');
                createRoomButton.disabled = true;
                joinRoomButton.disabled = true;

                try {
                    const roomId = generateRoomId();
                    currentRoomId = roomId;
                    // Corrected Firestore path: using collection for nested path segments
                    const roomRef = doc(collection(db, 'artifacts', appId, 'public', 'data', 'quiz_rooms'), roomId);

                    // Generate questions for the quiz
                    const selectedItems = shuffle([...availableItems]).slice(0, numQuestions);
                    const generatedQuestions = [];
                    for (const item of selectedItems) {
                        const question = await generateQuizQuestion(item);
                        if (question) {
                            generatedQuestions.push(question);
                        } else {
                            console.warn(`Failed to generate question for item: ${item}`);
                        }
                    }

                    if (generatedQuestions.length === 0) {
                        roomFeedback.textContent = "Impossibile generare domande per la categoria selezionata. Riprova.";
                        roomFeedback.className = "text-sm mt-2 text-red-500";
                        roomFeedback.classList.remove('hidden');
                        return;
                    }

                    await setDoc(roomRef, {
                        hostId: currentUserId,
                        category: category,
                        numQuestions: generatedQuestions.length,
                        players: {
                            [currentUserId]: { name: currentUserName, score: 0, lastAnswer: null, answered: false }
                        },
                        state: "lobby", // lobby, question, answering, revealing, finished
                        currentQuestionIndex: 0,
                        currentQuestion: null,
                        questionStartTime: null,
                        questionEndTime: null,
                        questions: generatedQuestions, // Store all questions
                        createdAt: serverTimestamp()
                    });

                    console.log("Room created:", roomId);
                    setupRoomListener(roomId);
                    showScreen('quiz-lobby-screen');
                    lobbyRoomIdDisplay.textContent = roomId;

                } catch (error) {
                    roomFeedback.textContent = `Errore nella creazione della stanza: ${error.message}`;
                    roomFeedback.className = "text-sm mt-2 text-red-500";
                    roomFeedback.classList.remove('hidden');
                    console.error("Error creating room:", error);
                } finally {
                    roomSpinner.classList.add('hidden');
                    createRoomButton.disabled = false;
                    joinRoomButton.disabled = false;
                }
            }

            async function joinRoom() {
                const nickname = playerNicknameInput.value.trim();
                if (!nickname) {
                    roomFeedback.textContent = "Inserisci un nickname per unirti a una stanza.";
                    roomFeedback.className = "text-sm mt-2 text-red-500";
                    roomFeedback.classList.remove('hidden');
                    return;
                }
                currentUserName = nickname;
                localStorage.setItem('playerNickname', nickname); // Persist nickname

                const roomId = roomIdInput.value.trim().toUpperCase();
                if (!roomId) {
                    roomFeedback.textContent = "Inserisci l'ID della stanza.";
                    roomFeedback.className = "text-sm mt-2 text-red-500";
                    roomFeedback.classList.remove('hidden');
                    return;
                }

                roomSpinner.classList.remove('hidden');
                roomFeedback.classList.add('hidden');
                createRoomButton.disabled = true;
                joinRoomButton.disabled = true;

                try {
                    // Corrected Firestore path: using collection for nested path segments
                    const roomRef = doc(collection(db, 'artifacts', appId, 'public', 'data', 'quiz_rooms'), roomId);
                    const roomSnap = await getDoc(roomRef);

                    if (!roomSnap.exists()) {
                        roomFeedback.textContent = "Stanza non trovata. Controlla l'ID.";
                        roomFeedback.className = "text-sm mt-2 text-red-500";
                        roomFeedback.classList.remove('hidden');
                        return;
                    }

                    currentRoomId = roomId;
                    await updateDoc(roomRef, {
                        [`players.${currentUserId}`]: { name: currentUserName, score: 0, lastAnswer: null, answered: false }
                    });

                    console.log("Joined room:", roomId);
                    setupRoomListener(roomId);
                    showScreen('quiz-lobby-screen');
                    lobbyRoomIdDisplay.textContent = roomId;

                } catch (error) {
                    roomFeedback.textContent = `Errore nell'unione alla stanza: ${error.message}`;
                    roomFeedback.className = "text-sm mt-2 text-red-500";
                    roomFeedback.classList.remove('hidden');
                    console.error("Error joining room:", error);
                } finally {
                    roomSpinner.classList.add('hidden');
                    createRoomButton.disabled = false;
                    joinRoomButton.disabled = false;
                }
            }

            async function leaveRoom() {
                if (currentRoomId && currentUserId) {
                    try {
                        if (unsubscribeRoomListener) {
                            unsubscribeRoomListener(); // Stop listening to room updates
                            unsubscribeRoomListener = null;
                        }

                        // Corrected Firestore path: using collection for nested path segments
                        const roomRef = doc(collection(db, 'artifacts', appId, 'public', 'data', 'quiz_rooms'), currentRoomId);
                        const roomSnap = await getDoc(roomRef);
                        
                        if (roomSnap.exists()) {
                            const roomData = roomSnap.data();
                            if (roomData.hostId === currentUserId) {
                                // If host leaves, delete the room
                                await deleteDoc(roomRef);
                                console.log("Host left, room deleted.");
                            } else {
                                // If player leaves, remove them from players list
                                await updateDoc(roomRef, {
                                    [`players.${currentUserId}`]: firebase.deleteField()
                                });
                                console.log("Player left the room.");
                            }
                        }
                    } catch (error) {
                        console.error("Error leaving room:", error);
                    } finally {
                        currentRoomId = null;
                        initApp(); // Go back to main menu
                    }
                } else {
                    initApp(); // Just go back to main menu if no room is active
                }
            }

            function setupRoomListener(roomId) {
                if (unsubscribeRoomListener) {
                    unsubscribeRoomListener(); // Unsubscribe from previous listener if any
                }

                // Corrected Firestore path: using collection for nested path segments
                const roomRef = doc(collection(db, 'artifacts', appId, 'public', 'data', 'quiz_rooms'), roomId);
                unsubscribeRoomListener = onSnapshot(roomRef, (docSnap) => {
                    if (docSnap.exists()) {
                        const roomData = docSnap.data();
                        console.log("Room data updated:", roomData);
                        updateLobbyUI(roomData);
                        handleGameState(roomData);
                    } else {
                        console.log("Room no longer exists. Returning to main menu.");
                        roomFeedback.textContent = "La stanza non esiste pi√π o √® stata chiusa dall'host.";
                        roomFeedback.className = "text-sm mt-2 text-red-500";
                        roomFeedback.classList.remove('hidden');
                        leaveRoom(); // Automatically leave if room is deleted
                    }
                }, (error) => {
                    console.error("Error listening to room:", error);
                    roomFeedback.textContent = `Errore di connessione alla stanza: ${error.message}`;
                    roomFeedback.className = "text-sm mt-2 text-red-500";
                    roomFeedback.classList.remove('hidden');
                });
            }

            function updateLobbyUI(roomData) {
                if (mainMenuScreen.classList.contains('hidden')) { // Only update if not on main menu
                    lobbyRoomIdDisplay.textContent = currentRoomId;
                    playersList.innerHTML = '';
                    const players = Object.values(roomData.players || {});
                    players.forEach(player => {
                        const li = document.createElement('li');
                        li.textContent = player.name;
                        if (player.name === currentUserName) { // Highlight current player
                            li.classList.add('font-bold', 'text-blue-600');
                        }
                        playersList.appendChild(li);
                    });

                    if (roomData.hostId === currentUserId) {
                        startQuizButton.classList.remove('hidden');
                        startQuizButton.disabled = players.length < 2; // Enable if at least 2 players
                        if (players.length < 2) {
                            lobbyFeedback.textContent = "Attendi almeno 2 giocatori per iniziare.";
                            lobbyFeedback.className = "text-sm mt-2 text-orange-500";
                            lobbyFeedback.classList.remove('hidden');
                        } else {
                            lobbyFeedback.classList.add('hidden');
                        }
                    } else {
                        startQuizButton.classList.add('hidden');
                        lobbyFeedback.textContent = "In attesa che l'host avvii il quiz...";
                        lobbyFeedback.className = "text-sm mt-2 text-gray-600";
                        lobbyFeedback.classList.remove('hidden');
                    }
                }
            }

            async function startGame() {
                if (currentRoomId && currentUserId) {
                    // Corrected Firestore path: using collection for nested path segments
                    const roomRef = doc(collection(db, 'artifacts', appId, 'public', 'data', 'quiz_rooms'), currentRoomId);
                    const roomSnap = await getDoc(roomRef);
                    if (!roomSnap.exists()) {
                        console.error("Room does not exist when trying to start game.");
                        return;
                    }
                    if (roomSnap.data().hostId !== currentUserId) {
                        console.error("Only host can start the game.");
                        return;
                    }

                    const roomData = roomSnap.data();
                    if (Object.keys(roomData.players).length < 2) {
                        lobbyFeedback.textContent = "Non puoi iniziare senza almeno 2 giocatori.";
                        lobbyFeedback.className = "text-sm mt-2 text-red-500";
                        lobbyFeedback.classList.remove('hidden');
                        return;
                    }

                    // Reset player scores for a new game
                    let updatedPlayers = {};
                    for (const playerId in roomData.players) {
                        updatedPlayers[playerId] = { ...roomData.players[playerId], score: 0, lastAnswer: null, answered: false };
                    }

                    await updateDoc(roomRef, {
                        state: "question",
                        currentQuestionIndex: 0,
                        currentQuestion: roomData.questions[0],
                        questionStartTime: serverTimestamp(),
                        questionEndTime: null, // Will be set when question is revealed
                        players: updatedPlayers
                    });
                    console.log("Game started by host.");
                }
            }

            async function handleGameState(roomData) {
                const isHost = roomData.hostId === currentUserId;

                if (roomData.state === "lobby") {
                    showScreen('quiz-lobby-screen');
                    updateLobbyUI(roomData);
                    clearInterval(questionTimerInterval);
                } else if (roomData.state === "question") {
                    showScreen('quiz-game-screen');
                    displayQuestion(roomData);
                    startQuestionTimer(roomData);
                    answerFeedbackDisplay.classList.add('hidden');
                    quizSpinner.classList.add('hidden');
                    nextQuestionButton.classList.add('hidden');
                    endQuizButton.classList.add('hidden');
                } else if (roomData.state === "revealing") {
                    displayQuestion(roomData); // Re-display to show correct/incorrect
                    revealAnswer(roomData);
                    clearInterval(questionTimerInterval);
                    if (isHost) {
                        nextQuestionButton.classList.remove('hidden');
                        endQuizButton.classList.remove('hidden');
                    }
                } else if (roomData.state === "finished") {
                    showScreen('quiz-results-screen');
                    displayFinalScores(roomData);
                    clearInterval(questionTimerInterval);
                }
                updateQuizScoresUI(roomData);
            }

            function displayQuestion(roomData) {
                const currentQuestion = roomData.currentQuestion;
                const playerState = roomData.players[currentUserId];

                currentQuestionNumberDisplay.textContent = roomData.currentQuestionIndex + 1;
                totalQuestionsDisplay.textContent = roomData.numQuestions;
                questionTextDisplay.textContent = currentQuestion.question;
                questionOptionsContainer.innerHTML = '';

                shuffle([...currentQuestion.options]).forEach(option => {
                    const button = document.createElement('button');
                    button.textContent = option;
                    button.classList.add('hover:scale-105', 'transform', 'transition-transform');
                    button.addEventListener('click', () => submitAnswer(option));

                    // Disable buttons if already answered or game state is revealing/finished
                    if (roomData.state === "revealing" || roomData.state === "finished" || playerState.answered) {
                        button.disabled = true;
                    }

                    // Apply styles if answer is revealed
                    if (roomData.state === "revealing") {
                        if (option === currentQuestion.correctAnswer) {
                            button.classList.add('correct');
                        } else if (playerState.lastAnswer === option && playerState.lastAnswer !== currentQuestion.correctAnswer) {
                            button.classList.add('incorrect');
                        }
                    }
                    // Highlight selected answer if already answered
                    if (playerState.lastAnswer === option && roomData.state !== "revealing") {
                        button.classList.add('selected');
                    }

                    questionOptionsContainer.appendChild(button);
                });
            }

            function startQuestionTimer(roomData) {
                clearInterval(questionTimerInterval); // Clear any existing timer
                timerBar.style.width = '100%';
                timerBar.style.backgroundColor = '#4CAF50';

                const startTime = roomData.questionStartTime ? roomData.questionStartTime.toDate().getTime() : Date.now();
                const endTime = startTime + (QUESTION_TIME_LIMIT * 1000);

                questionTimerInterval = setInterval(() => {
                    const now = Date.now();
                    const timeLeft = endTime - now;

                    if (timeLeft <= 0) {
                        clearInterval(questionTimerInterval);
                        if (roomData.hostId === currentUserId && roomData.state === "question") {
                            // Host automatically reveals answer if time runs out
                            updateDoc(doc(collection(db, 'artifacts', appId, 'public', 'data', 'quiz_rooms'), currentRoomId), {
                                state: "revealing",
                                questionEndTime: serverTimestamp()
                            });
                        }
                    } else {
                        const progress = (timeLeft / (QUESTION_TIME_LIMIT * 1000)) * 100;
                        timerBar.style.width = `${progress}%`;
                        if (progress < 25) {
                            timerBar.style.backgroundColor = '#f44336'; // Red
                        } else if (progress < 50) {
                            timerBar.style.backgroundColor = '#ff9800'; // Orange
                        } else {
                            timerBar.style.backgroundColor = '#4CAF50'; // Green
                        }
                    }
                }, 100); // Update every 100ms
            }

            async function submitAnswer(selectedOption) {
                if (!currentRoomId || !currentUserId) return;

                // Corrected Firestore path: using collection for nested path segments
                const roomRef = doc(collection(db, 'artifacts', appId, 'public', 'data', 'quiz_rooms'), currentRoomId);
                const roomSnap = await getDoc(roomRef);
                if (!roomSnap.exists()) return;

                const roomData = roomSnap.data();
                const playerState = roomData.players[currentUserId];

                if (roomData.state !== "question" || playerState.answered) {
                    return; // Can only answer if in 'question' state and not already answered
                }

                // Mark player as answered and store their answer
                await updateDoc(roomRef, {
                    [`players.${currentUserId}.lastAnswer`]: selectedOption,
                    [`players.${currentUserId}.answered`]: true
                });

                // Visually mark the selected option
                Array.from(questionOptionsContainer.children).forEach(button => {
                    if (button.textContent === selectedOption) {
                        button.classList.add('selected');
                    }
                    button.disabled = true; // Disable all options after answering
                });

                answerFeedbackDisplay.textContent = "Risposta inviata!";
                answerFeedbackDisplay.className = "text-sm mt-2 text-green-600";
                answerFeedbackDisplay.classList.remove('hidden');

                // Check if all players have answered (only host does this check)
                if (roomData.hostId === currentUserId) {
                    const allPlayersAnswered = Object.values(roomData.players).every(p => p.answered);
                    if (allPlayersAnswered) {
                        clearInterval(questionTimerInterval); // Stop timer
                        await updateDoc(roomRef, {
                            state: "revealing",
                            questionEndTime: serverTimestamp()
                        });
                    }
                }
            }

            async function revealAnswer(roomData) {
                const currentQuestion = roomData.currentQuestion;
                const players = roomData.players;
                const isHost = roomData.hostId === currentUserId;

                // Update UI for correct/incorrect answers
                Array.from(questionOptionsContainer.children).forEach(button => {
                    button.disabled = true; // Ensure all buttons are disabled
                    if (button.textContent === currentQuestion.correctAnswer) {
                        button.classList.add('correct');
                    } else if (button.classList.contains('selected')) {
                        button.classList.add('incorrect');
                    }
                });

                // Update scores (only host should do this to prevent race conditions)
                if (isHost && roomData.state === "revealing") {
                    let updatedPlayers = { ...players };
                    for (const playerId in updatedPlayers) {
                        const player = updatedPlayers[playerId];
                        // Only award points if they answered correctly and haven't already been scored for this question
                        if (player.lastAnswer === currentQuestion.correctAnswer && !player.scoredForCurrentQuestion) {
                            updatedPlayers[playerId].score += 10; // Award points
                            updatedPlayers[playerId].scoredForCurrentQuestion = true; // Mark as scored
                        }
                    }
                    // Corrected Firestore path: using collection for nested path segments
                    await updateDoc(doc(collection(db, 'artifacts', appId, 'public', 'data', 'quiz_rooms'), currentRoomId), {
                        players: updatedPlayers
                    });
                }
                answerFeedbackDisplay.classList.add('hidden'); // Hide "Answer submitted" feedback
            }

            function updateQuizScoresUI(roomData) {
                quizPlayersScoresList.innerHTML = '';
                const playersArray = Object.values(roomData.players || {}).sort((a, b) => b.score - a.score); // Sort by score

                playersArray.forEach(player => {
                    const li = document.createElement('li');
                    li.classList.add('player-score-item');
                    if (player.name === currentUserName) {
                        li.classList.add('current-player');
                    }
                    li.innerHTML = `<span class="player-name">${player.name}</span><span class="player-score">${player.score}</span>`;
                    quizPlayersScoresList.appendChild(li);
                });
            }

            async function nextQuestion() {
                // Corrected Firestore path: using collection for nested path segments
                if (!currentRoomId || currentUserId !== (await getDoc(doc(collection(db, 'artifacts', appId, 'public', 'data', 'quiz_rooms'), currentRoomId))).data().hostId) {
                    return; // Only host can advance
                }

                // Corrected Firestore path: using collection for nested path segments
                const roomRef = doc(collection(db, 'artifacts', appId, 'public', 'data', 'quiz_rooms'), currentRoomId);
                const roomSnap = await getDoc(roomRef);
                if (!roomSnap.exists()) return;
                const roomData = roomSnap.data();

                const nextIndex = roomData.currentQuestionIndex + 1;

                if (nextIndex < roomData.numQuestions) {
                    // Reset answered state for all players for the next question
                    let updatedPlayers = {};
                    for (const playerId in roomData.players) {
                        updatedPlayers[playerId] = { ...roomData.players[playerId], lastAnswer: null, answered: false, scoredForCurrentQuestion: false };
                    }

                    await updateDoc(roomRef, {
                        state: "question",
                        currentQuestionIndex: nextIndex,
                        currentQuestion: roomData.questions[nextIndex],
                        questionStartTime: serverTimestamp(),
                        questionEndTime: null,
                        players: updatedPlayers
                    });
                } else {
                    // End of quiz
                    await updateDoc(roomRef, {
                        state: "finished",
                        questionEndTime: serverTimestamp()
                    });
                }
            }

            function displayFinalScores(roomData) {
                finalScoresList.innerHTML = '';
                const playersArray = Object.values(roomData.players || {}).sort((a, b) => b.score - a.score);

                playersArray.forEach((player, index) => {
                    const li = document.createElement('li');
                    li.classList.add('flex', 'justify-between', 'items-center', 'py-2', 'px-4', 'border-b', 'border-gray-200');
                    if (index === 0) { // Highlight winner
                        li.classList.add('bg-yellow-100', 'font-bold', 'text-yellow-800', 'rounded-t-lg');
                        li.innerHTML = `<span>üèÜ ${player.name}</span><span>${player.score} punti</span>`;
                    } else {
                        li.innerHTML = `<span>${index + 1}. ${player.name}</span><span>${player.score} punti</span>`;
                    }
                    finalScoresList.appendChild(li);
                });
            }

            // --- INITIALIZATION ---
            function initApp() {
                showScreen('loading-screen'); // Start with loading screen
                // Clear all dynamic content
                bracket.innerHTML = '';
                winnerDisplay.innerHTML = '';
                aiCategoryPromptInput.value = '';
                generateFeedback.classList.add('hidden');
                generateSpinner.classList.add('hidden');
                roomFeedback.classList.add('hidden');
                roomSpinner.classList.add('hidden');
                lobbyFeedback.classList.add('hidden');
                lobbySpinner.classList.add('hidden');
                answerFeedbackDisplay.classList.add('hidden');
                quizSpinner.classList.add('hidden');
                playerNicknameInput.value = localStorage.getItem('playerNickname') || ''; // Load nickname from local storage
                roomIdInput.value = '';
                clearInterval(questionTimerInterval);
                timerBar.style.width = '100%';
                timerBar.style.backgroundColor = '#4CAF50';
                
                // Set a timeout to ensure the main menu eventually appears,
                // even if Firebase loading encounters an unexpected halt.
                setTimeout(() => {
                    if (loadingScreen.classList.contains('hidden')) {
                        // Already loaded by Firebase, do nothing.
                    } else {
                        console.warn("Firebase loading timeout: Showing main menu without full data confirmation.");
                        showScreen('main-menu-screen');
                        updateCategorySelects(); // Attempt to update with whatever data is available
                    }
                }, 5000); // 5 seconds timeout
            }

            // --- Firebase Authentication and Data Loading ---
            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    currentUserId = user.uid;
                    userIdDisplay.textContent = `ID Utente: ${currentUserId}`;
                    console.log("Authenticated as:", currentUserId);

                    const categoriesColRef = collection(db, `artifacts/${appId}/users/${currentUserId}/categories`);
                    let initialSnapshotLoaded = false;

                    onSnapshot(categoriesColRef, (snapshot) => {
                        console.log("Firestore snapshot received for categories.");
                        snapshot.docChanges().forEach(change => {
                            const categoryName = change.doc.id;
                            const categoryData = change.doc.data();
                            if (change.type === "added" || change.type === "modified") {
                                dishData[categoryName] = categoryData.items;
                                console.log(`Category ${categoryName} loaded/updated.`);
                            } else if (change.type === "removed") {
                                delete dishData[categoryName];
                                console.log(`Category ${categoryName} removed.`);
                            }
                        });
                        updateCategorySelects();
                        
                        if (!initialSnapshotLoaded) {
                            showScreen('main-menu-screen'); // Show main menu after initial categories load
                            initialSnapshotLoaded = true;
                            console.log("Initial categories loaded, showing main menu.");
                        }
                    }, (error) => {
                        console.error("Error listening to categories:", error);
                        loadingScreen.innerHTML = `<p class="text-red-500">Errore nel caricamento delle categorie: ${error.message}</p>`;
                        if (!initialSnapshotLoaded) {
                            showScreen('main-menu-screen');
                            initialSnapshotLoaded = true;
                            console.log("Error loading categories, showing main menu with fallback.");
                        }
                    });

                } else {
                    console.log("No user authenticated, attempting anonymous sign-in.");
                    try {
                        if (window.__initial_auth_token) {
                            await signInWithCustomToken(auth, window.__initial_auth_token);
                            console.log("Signed in with custom token.");
                        } else {
                            await signInAnonymously(auth);
                            console.log("Signed in anonymously.");
                        }
                    } catch (error) {
                        console.error("Error signing in:", error);
                        loadingScreen.innerHTML = `<p class="text-red-500">Errore di autenticazione: ${error.message}</p>`;
                        showScreen('main-menu-screen');
                        updateCategorySelects();
                    }
                }
            });

            // --- Event Listeners ---
            startSoloTournamentButton.addEventListener('click', () => showScreen('solo-start-screen'));
            startMultiplayerQuizButton.addEventListener('click', () => showScreen('multiplayer-setup-screen'));
            backToMainMenuButton.addEventListener('click', initApp);
            resetSoloButton.addEventListener('click', initApp);
            playAgainButton.addEventListener('click', initApp);
            returnToMainMenuQuizEndButton.addEventListener('click', initApp);


            startTournamentButton.addEventListener('click', function() {
                const selectedCategory = categorySelect.value;
                const selectedSize = parseInt(sizeSelect.value);
                
                if (selectedSize > dishData[selectedCategory].length) {
                    console.error("Not enough items for the selected tournament size in this category.");
                    return;
                }

                showScreen('solo-tournament-container');
                createSoloTournament(dishData[selectedCategory], selectedSize);
            });

            categorySelect.addEventListener('change', () => validateTournamentSize(categorySelect, sizeWarning, startTournamentButton, 'solo'));
            sizeSelect.addEventListener('change', () => validateTournamentSize(categorySelect, sizeWarning, startTournamentButton, 'solo'));
            quizCategorySelect.addEventListener('change', () => validateTournamentSize(quizCategorySelect, quizSizeWarning, createRoomButton, 'quiz'));
            quizSizeSelect.addEventListener('change', () => validateTournamentSize(quizCategorySelect, quizSizeWarning, createRoomButton, 'quiz'));

            createRoomButton.addEventListener('click', createRoom);
            joinRoomButton.addEventListener('click', joinRoom);
            leaveRoomButton.addEventListener('click', leaveRoom);
            startQuizButton.addEventListener('click', startGame);
            nextQuestionButton.addEventListener('click', nextQuestion);
            endQuizButton.addEventListener('click', leaveRoom); // End quiz button also leaves the room

            // --- INITIALIZATION CALL ---
            initApp();
        });
    </script>
</body>
</html>